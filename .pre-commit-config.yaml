# Pre-commit hooks para Taiga FastAPI UV
# Ver https://pre-commit.com para m√°s informaci√≥n

repos:
  # Hooks b√°sicos de pre-commit
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
        name: Eliminar espacios en blanco al final
      - id: end-of-file-fixer
        name: Asegurar nueva l√≠nea al final del archivo
      - id: check-yaml
        name: Validar sintaxis YAML
      - id: check-json
        name: Validar sintaxis JSON
      - id: check-toml
        name: Validar sintaxis TOML
      - id: check-merge-conflict
        name: Verificar marcadores de merge conflict
      - id: check-added-large-files
        name: Verificar archivos grandes
        args: ['--maxkb=1000']
      - id: detect-private-key
        name: Detectar claves privadas
      - id: check-case-conflict
        name: Verificar conflictos de may√∫sculas/min√∫sculas

  # Formateo de c√≥digo Python (usando uv)
  - repo: local
    hooks:
      - id: black
        name: Formatear c√≥digo con Black
        entry: uv run black
        language: system
        types: [python]
        args: [--line-length=100]

  # Ordenamiento de imports (usando uv)
  - repo: local
    hooks:
      - id: isort
        name: Ordenar imports con isort
        entry: uv run isort
        language: system
        types: [python]
        args: [--profile=black, --line-length=100]

  # Linting con flake8 (usando uv)
  - repo: local
    hooks:
      - id: flake8
        name: Linting con flake8
        entry: uv run flake8
        language: system
        types: [python]
        args: [--max-line-length=100, --extend-ignore=E203,W503]

  # An√°lisis est√°tico con pylint
  - repo: local
    hooks:
      - id: pylint
        name: An√°lisis est√°tico con pylint
        entry: uv run pylint
        language: system
        types: [python]
        args: [--rcfile=pyproject.toml]

  # Tests con pytest (solo obligatorio en main)
  - repo: local
    hooks:
      - id: pytest
        name: Ejecutar tests con pytest
        entry: bash
        language: system
        types: [python]
        pass_filenames: false
        args: [-c, '
          # Verificar si estamos en main o si se fuerza la ejecuci√≥n
          BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
          if [ "$BRANCH" = "main" ] || [ "$SKIP_TESTS" != "1" ]; then
            echo "üß™ Ejecutando tests (rama: $BRANCH)..."
            uv run pytest --tb=short -v
          else
            echo "‚è≠Ô∏è  Tests omitidos (rama: $BRANCH, SKIP_TESTS=1)"
            echo "‚ö†Ô∏è  Recuerda ejecutar tests antes de merge a main"
          fi
        ']

  # Validaci√≥n de secretos y datos sensibles
  - repo: local
    hooks:
      - id: check-env-secrets
        name: Verificar que no se commiteen secretos del .env
        entry: python3
        language: system
        args:
          - -c
          - |
            import sys
            import re
            from pathlib import Path

            files = [f for f in sys.argv[1:] if f.endswith(('.py', '.md', '.yml', '.yaml'))]
            # Excluir archivos de test y documentaci√≥n
            files = [f for f in files if not f.startswith('tests/') and 'test_' not in f]

            # Patrones solo para archivos .env (que no deber√≠an estar en git)
            env_patterns = [
              r'TAIGA_PASSWORD=(?!.*example|.*placeholder|.*your_password)',
              r'TAIGA_USERNAME=(?!.*example|.*placeholder|.*your_username)',
              r'TAIGA_AUTH_TOKEN=(?!.*example|.*placeholder|.*your_token|.*eyJ0eXAi)',
            ]

            violations = []
            for file in files:
              try:
                with open(file, 'r', encoding='utf-8') as f:
                  content = f.read()
                  # Solo verificar patrones de .env en archivos que no sean .env.example
                  if '.env' in file and 'example' not in file:
                    for pattern in env_patterns:
                      if re.search(pattern, content, re.IGNORECASE):
                        violations.append(f'{file}: Contiene credenciales reales')
              except Exception:
                pass

            if violations:
              print('‚ùå SECRETOS DETECTADOS:')
              for v in violations:
                print(f'  {v}')
              sys.exit(1)
            print('‚úÖ No se detectaron secretos')
        types: [text]

  # Validaci√≥n de datos de usuario reales
  - repo: local
    hooks:
      - id: check-real-user-data
        name: Verificar que no se commiteen datos de usuario reales
        entry: python3
        language: system
        args:
          - -c
          - |
            import sys
            import re
            files = [f for f in sys.argv[1:] if f.endswith(('.py', '.md', '.yml', '.yaml'))]
            forbidden_patterns = [
              r'fpiaggi-ext@sidom\.io',
              r'fernandop(?!.*example)',
              r'P3p3r1na\.',
              r'taiga\.vuce\.gob\.ar(?!.*example)',
            ]
            for file in files:
              try:
                with open(file, 'r', encoding='utf-8') as f:
                  content = f.read()
                  for pattern in forbidden_patterns:
                    if re.search(pattern, content):
                      print(f'‚ùå DATOS REALES DETECTADOS en {file}')
                      sys.exit(1)
              except Exception:
                pass
            print('‚úÖ No se detectaron datos de usuario reales')
        types: [text]

  # Validaci√≥n de formato de commit
  - repo: local
    hooks:
      - id: validate-commit-format
        name: Validar formato Conventional Commits
        entry: bash
        language: system
        stages: [commit-msg]
        args: [-c, '
          COMMIT_MSG_FILE=$1
          COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

          # Patr√≥n para Conventional Commits
          if ! echo "$COMMIT_MSG" | grep -qE "^(feat|fix|docs|style|refactor|test|chore|perf|ci|build)(\(.+\))?: .+"; then
            echo "‚ùå FORMATO DE COMMIT INV√ÅLIDO"
            echo ""
            echo "Formato: tipo(√°mbito): descripci√≥n"
            echo "Tipos: feat, fix, docs, style, refactor, test, chore, perf, ci, build"
            echo ""
            echo "Ejemplos:"
            echo "  feat(auth): agregar soporte para tokens"
            echo "  fix(client): corregir timeout"
            echo "  docs: actualizar README"
            exit 1
          fi

          echo "‚úÖ Formato v√°lido"
        ', --]
        pass_filenames: true

  # Actualizaci√≥n autom√°tica de changelog (se ejecuta en prepare-commit-msg)
  - repo: local
    hooks:
      - id: update-changelog
        name: Actualizar CHANGELOG.md autom√°ticamente
        entry: bash
        language: system
        stages: [prepare-commit-msg]
        args: [-c, '
          COMMIT_MSG_FILE=$1
          COMMIT_SOURCE=$2

          # Solo procesar commits normales (no merges, ammends, etc)
          if [ -n "$COMMIT_SOURCE" ]; then
            exit 0
          fi

          # Leer mensaje del commit
          COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

          # Validar formato Conventional Commits
          if ! echo "$COMMIT_MSG" | grep -qE "^(feat|fix|docs|style|refactor|test|chore|perf|ci|build)(\(.+\))?: .+"; then
            echo "‚ö†Ô∏è  Commit no sigue formato convencional, saltando changelog"
            exit 0
          fi

          # Extraer tipo y descripci√≥n
          TYPE=$(echo "$COMMIT_MSG" | sed -E "s/^([a-z]+)(\(.+\))?: .*/\1/")
          DESC=$(echo "$COMMIT_MSG" | sed -E "s/^[a-z]+(\(.+\))?: (.+)/\2/")

          # Determinar secci√≥n
          case "$TYPE" in
            feat) SECTION="Added" ;;
            fix) SECTION="Fixed" ;;
            *) SECTION="Changed" ;;
          esac

          # Actualizar CHANGELOG.md
          if [ -f "CHANGELOG.md" ]; then
            # Crear entrada
            ENTRY="- $DESC"

            # Buscar secci√≥n Unreleased y agregar entrada
            if grep -q "## \[Unreleased\]" CHANGELOG.md; then
              # Verificar si la secci√≥n existe
              if grep -A 20 "## \[Unreleased\]" CHANGELOG.md | grep -q "### $SECTION"; then
                # Agregar a secci√≥n existente
                sed -i "/### $SECTION/a $ENTRY" CHANGELOG.md
              else
                # Crear nueva secci√≥n despu√©s de Unreleased
                sed -i "/## \[Unreleased\]/a \\\n### $SECTION\n$ENTRY" CHANGELOG.md
              fi

              git add CHANGELOG.md
              echo "‚úÖ CHANGELOG.md actualizado: $ENTRY"
            fi
          fi
        ', --]
        pass_filenames: true

# Configuraci√≥n global
default_stages: [commit]
fail_fast: false
